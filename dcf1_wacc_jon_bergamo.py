# -*- coding: utf-8 -*-
"""DCF1 WACC - Jon Bergamo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gCxaaDoGMc1kxBMgpYTbf_z7-dYnu103

# DCF Part 1: WACC

In this notebook, we will compute the weighted average cost of capital.

$WACC = w_E * k_E + w_D * k_D * (1-t)$

Steps to get there:
1. Get firm data to compute Equity and Debt weights ($w_E$ and $w_D$)
2. Compute the cost of equity using the CAPM: $k_E = r_f + B_i * EMRP$

We'll get the risk free rate from market data.
We'll use an OLS regression to compute our own Beta.
The EMRP we will take as given.

3. Compute the cost of debt: $k_D = r_f + spread$

The $spread$ is the default spread given a firm's credit rating. We'll use a lookup table using current data to get the spread.

4. $t$ is the marginal tax rate, which we'll take as 25%.
5. Put it all together!

This is our in-class project that we will work on progressively through the mod.

Expectations:
1. Notebook is clean and neat, with no repeated code. It has clearly labeled sections for inputs/imports at the beginning. Code is sufficiently commented to demonstrate your understanding of the code and help you or anyone else who may use this code later. All numbers should be formatted so they are readable (so, use commas with large numbers, only a few decimal points).
2. All calculations are correct and all discussion questions are answered completely but concisely, demonstrating a depth of understanding.

Workflow:
1. Notebooks are inherently experimental and allow you to try things, however that requires some good habits
2. Once you are "done" in any sense, you always need to "clean up" your notebook to make it presentable. You'd do the same in Excel - you've tried lots of things, etc. but before you present it, you clean it up.
3. Finally, restart the Runtime/Kernel and run it cleanly all the way top to bottom one time.

Then, its ready to go.

# 1 Always put Imports and Installs at the beginning

And only put them in once.

Set display options here if you are using them.

Set API Keys here if you need them.
"""

# necessary imports
import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import seaborn as sns

import yfinance as yf

import statsmodels.api as sm

# Format setting for the model - tame the decimals!
pd.reset_option('display.float_format')
pd.set_option('display.float_format', lambda x: '{:,.2f}'.format(x))

# install the FRED API for economic data
# This is necessary since Google Colab does not have this package installed already
#%%capture
!pip install fredapi

# import
import fredapi
# These two lines set the API Key so you can access FRED data with your credentials
from google.colab import userdata
fred = fredapi.Fred(api_key=userdata.get('FRED_APIKey'))

"""# 2 Gather inputs, assumptions, parameters at the beginning

This is a place for anything that you may want to change in the future. The rest of the notebook should just be code that runs, generating the necessary output, plots, etc.

### Assumptions and paramters

"""

# Set Ticker we are modeling
ticker_symbol = 'MSFT'
company_name = "Microsoft"

firm_rating = "Aaa/AAA"

# choose the "market" for our beta - get from Yahoo! Finance
index_symbol = '^GSPC'
index_name = "S&P 500"

# get risk free rate from FRED
# first, get the whole series
rf_series = fred.get_series('DGS10')

# get the most recent value, divide by 100 to make it a decimal like all others
rf = rf_series.iloc[-1] / 100

#print the risk free rate
print(f"Risk Free Rate: {rf:.2%}")

emrp = 0.05 # given
marg_tax_rate = 0.25 # for WACC, given

# this is what we divide numbers by, 1000000 is $M
scale_factor = 1000000
scale_name = '$M'

"""# 3 Begin Calculations and Modeling

**From here, nothing should be hardcoded**

## Debt and Equity Weights
"""

# Create a Ticker object from Yahoo!
ticker = yf.Ticker(ticker_symbol)


# Get the market cap and total debt (use right scale factor from above)
market_cap = ticker.info['marketCap'] / scale_factor
total_debt = ticker.info['totalDebt'] / scale_factor

print(f"Market Capitalization for {ticker_symbol}: {market_cap:,.2f}")
print(f"Total Debt for {ticker_symbol}: {total_debt:,.2f}")

# compute equity and debt weights
w_E = market_cap / (market_cap + total_debt)
w_D = total_debt / (market_cap + total_debt)

print(f"Equity Weight for {ticker_symbol}: {w_E:,.2f}")
print(f"Debt Weight for {ticker_symbol}: {w_D:,.2f}")

ticker.info

"""## Cost of Equity

Really this is just beta because the other two are either given or looked up already.
"""

# Download historical data for the firm and S&P 500
# get five years of monthly data
stock_data = yf.download(ticker_symbol, period='5y', interval='1mo')
index_data = yf.download(index_symbol, period='5y', interval='1mo')

# Calculate monthly returns for stock and S&P 500, and subtract off the risk free rate
stock_returns = stock_data['Close'].pct_change().dropna() - rf
index_returns = index_data['Close'].pct_change().dropna() - rf

# Run OLS regression, be sure to add a constant to index returns
# this will use the statsmodels package (don't forget to import above...)
X = sm.add_constant(index_returns)
model = sm.OLS(stock_returns, X)
results = model.fit()

# Print out the regression results
print(results.summary())

# Get the beta - it is the coefficient on the index return, not the constant
beta = results.params[index_symbol]

print(f"Beta for {ticker_symbol}: {beta:.2f}")

# Calculate the cost of equity using CAPM
cost_of_equity = rf + beta * emrp

print(f"Cost of Equity for {ticker_symbol}: {cost_of_equity:.2%}")

"""## Cost of Debt

Really, just the spread is all we need.

I have a table that I like to use from Aswath Damodaran.
[Here is the link.](https://people.stern.nyu.edu/adamodar/New_Home_Page/datafile/ratings.html)


I updated it with the following prompt in ChatGPT:

*I have the following list structure for credit spreads in python:*

```
Paste old code table here
```
*Please update it with this new data (copied from a web site):*
```
Paste unformatted table text from Damodaran's website here
```

And that seems to work





"""

# Updated as of January 2025 for large non-financial service firms:
credit_spreads = [
    {"GreaterThan": -100000, "LessThan": 0.199999, "Rating": "D2/D", "Spread": 19.00},
    {"GreaterThan": 0.2, "LessThan": 0.649999, "Rating": "C2/C", "Spread": 15.50},
    {"GreaterThan": 0.65, "LessThan": 0.799999, "Rating": "Ca2/CC", "Spread": 10.10},
    {"GreaterThan": 0.8, "LessThan": 1.249999, "Rating": "Caa/CCC", "Spread": 7.28},
    {"GreaterThan": 1.25, "LessThan": 1.499999, "Rating": "B3/B-", "Spread": 4.42},
    {"GreaterThan": 1.5, "LessThan": 1.749999, "Rating": "B2/B", "Spread": 3.00},
    {"GreaterThan": 1.75, "LessThan": 1.999999, "Rating": "B1/B+", "Spread": 2.61},
    {"GreaterThan": 2, "LessThan": 2.2499999, "Rating": "Ba2/BB", "Spread": 1.83},
    {"GreaterThan": 2.25, "LessThan": 2.49999, "Rating": "Ba1/BB+", "Spread": 1.55},
    {"GreaterThan": 2.5, "LessThan": 2.999999, "Rating": "Baa2/BBB", "Spread": 1.20},
    {"GreaterThan": 3, "LessThan": 4.249999, "Rating": "A3/A-", "Spread": 0.95},
    {"GreaterThan": 4.25, "LessThan": 5.499999, "Rating": "A2/A", "Spread": 0.85},
    {"GreaterThan": 5.5, "LessThan": 6.499999, "Rating": "A1/A+", "Spread": 0.77},
    {"GreaterThan": 6.5, "LessThan": 8.499999, "Rating": "Aa2/AA", "Spread": 0.60},
    {"GreaterThan": 8.5, "LessThan": 100000, "Rating": "Aaa/AAA", "Spread": 0.45}
]

"""Here we are going to write a function. Remember, we'll do this in two overall steps:

1. Write a script (not a function) that does what you want it to do and check and be sure that all the logic works.
2. Turn that script into a function with inputs and outputs, etc.
"""

# write a function. It should take two inputs:
# 1. rating, a string variable that represents the firm's credit rating
# 2. credit_spreads, a list of dictionaries that has a lookup table from Damodaran's website.
# The table is in the above cell.
#
# The output should return a credit spread, which is a float data type.
# If no match is found, it should print a warning and return a NaN

def get_credit_spread(rating, credit_spreads):
    """
    Returns the credit spread for a given rating from the credit_spreads table.

    Parameters:
    rating (str): The credit rating (e.g., "A2/A", "Ba1/BB+")
    credit_spreads (list): A list of dictionaries containing rating and spread data

    Returns:
    float: The credit spread, or NaN if the rating is not found
    """
    for entry in credit_spreads:
        if entry["Rating"] == rating:
            return entry["Spread"]/100

    print(f"Warning: Rating '{rating}' not found in credit spread table.")
    return float('nan')

# Example usage
credit_spread = get_credit_spread(firm_rating, credit_spreads)

print(f"The spread for {ticker_symbol}'s rating ({firm_rating}) is: {credit_spread:.2%}")

# compute cost of debt: risk free rate plus credit spread
cost_of_debt = rf + get_credit_spread(firm_rating, credit_spreads)

print(f"Cost of Debt for {ticker_symbol}: {cost_of_debt:.2%}")

"""## Finally, compute the WACC

put it all together
"""

# Calculate WACC
wacc = w_E * cost_of_equity + w_D * cost_of_debt * (1 - marg_tax_rate)

print(f"WACC for {ticker_symbol}: {wacc:.2%}")

"""# Homework: What about Uncertainty?

Our estimate of beta has a range of uncertainty about it - a 95% confidence interval.

**HOMEWORK**

1. Go back to the OLS above and find the lower and upper CI for beta. Do this programmatically (i.e., find it in the `results` object)
2. Recompute a *lower* and *upper* WACC based on that *lower* and *upper* beta

If you are completely stuck, you should hard code the upper and Lower CI so you can turn this in, but there will be a deduction.

Expected output: A DataFrame, one column, three rows, with the Lower CI, the Estimate, and Upper CI version of the WACC, in that order.

## Get beta confidence intervals
"""

# Extract the confidence intervals from the results object
conf_int = results.conf_int(alpha=0.05)

# Get the lower and upper bounds for beta (which is the coefficient for the index symbol)
beta_lower = conf_int.loc[index_symbol, 0]
beta_upper = conf_int.loc[index_symbol, 1]

print(f"Lower bound of 95% CI for Beta: {beta_lower:.2f}")
print(f"Upper bound of 95% CI for Beta: {beta_upper:.2f}")

"""## Calculate lower and upper cost of equity

"""

# Calculate the lower bound of the cost of equity
cost_of_equity_lower = rf + beta_lower * emrp

# Calculate the upper bound of the cost of equity
cost_of_equity_upper = rf + beta_upper * emrp

# Print the lower and upper bounds of the cost of equity
print(f"Lower bound of Cost of Equity for {ticker_symbol}: {cost_of_equity_lower:.2%}")
print(f"Upper bound of Cost of Equity for {ticker_symbol}: {cost_of_equity_upper:.2%}")

"""## Calculate lower and upper wacc

"""

# Calculate the lower bound of the WACC
wacc_lower = w_E * cost_of_equity_lower + w_D * cost_of_debt * (1 - marg_tax_rate)

# Calculate the upper bound of the WACC
wacc_upper = w_E * cost_of_equity_upper + w_D * cost_of_debt * (1 - marg_tax_rate)

# Print the lower and upper WACC values
print(f"Lower bound of WACC for {ticker_symbol}: {wacc_lower:.2%}")
print(f"Upper bound of WACC for {ticker_symbol}: {wacc_upper:.2%}")

"""## Create and display dataframe

"""

# Create a list with the lower, estimated, and upper WACC
wacc_values = [wacc_lower, wacc, wacc_upper]

# Create a DataFrame from the list
wacc_df = pd.DataFrame(wacc_values, columns=['WACC'], index=['Lower CI', 'Estimate', 'Upper CI'])

# Display the DataFrame
display(wacc_df*100)

